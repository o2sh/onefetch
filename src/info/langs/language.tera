use owo_colors::{
    AnsiColors,
    DynColors::{self, Ansi, Rgb},
};
use std::convert::TryFrom;
use std::fmt;
use std::fmt::Write;
use strum::EnumIter;

pub struct Colors {
    basic_colors: Vec<DynColors>,
    true_colors: Option<Vec<DynColors>>,
}

#[derive(Clone, PartialEq, Eq, Debug, clap::ValueEnum)]
pub enum LanguageType {
    Programming,
    Markup,
    Prose,
    Data,
}

#[derive(Clone, Copy, PartialEq, Eq, Hash, EnumIter, clap::ValueEnum, Debug, Serialize)]
#[allow(clippy::upper_case_acronyms)]
#[clap(rename_all = "lowercase")]
pub enum Language {
    {% for language, attrs in languages -%}
        {% if attrs.serialization %}#[clap(name="{{ attrs.serialization }}")]{% endif -%}
        {{ language }},
    {% endfor %}
}

impl fmt::Display for Language {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            {% for language, _ in languages -%}
                Self::{{ language }} => write!(f, "{}", gengo::Language::{{ language }}.name()),
            {% endfor %}
        }
    }
}

impl TryFrom<gengo::Language> for Language {
    type Error = ();

    fn try_from(language: gengo::Language) -> Result<Self, Self::Error> {
        match language {
            {% for language, _ in languages -%}
                gengo::Language::{{ language }} => Ok(Self::{{ language }}),
            {% endfor %}
            _ => Err(()),
        }
    }
}

impl From<Language> for gengo::Language {
    fn from(language: Language) -> Self {
        match language {
            {% for language, _ in languages -%}
                Language::{{ language }} => gengo::Language::{{ language }},
            {% endfor %}
        }
    }
}

impl Language {
    pub fn get_ascii_art(&self) -> &'static str {
        match self {
            {% for language, attrs in languages -%}
                Language::{{ language }} => "{{ attrs.ascii | addslashes }}",
            {% endfor %}
        }
    }

    pub fn get_colors(&self, true_color: bool) -> Vec<DynColors> {
        let colors = match self {
            {% for language, attrs in languages -%}
                Language::{{ language }} => Colors {
                    basic_colors: vec![{%- for color in attrs.colors.ansi -%}Ansi(AnsiColors::{{ color | capitalize | replace(from="White", to="Default") }}),{% endfor %}],
                    true_colors: {% if attrs.colors.hex -%}
                        Some(vec![
                            {%- for hex in attrs.colors.hex -%}
                                {% set rgb = hex | hex_to_rgb -%}
                                Rgb({{ rgb.r }}, {{ rgb.g }}, {{ rgb.b }}),
                            {% endfor %}])
                    {% else -%}None
                    {% endif %},
                },
            {% endfor %}
        };
        match colors.true_colors {
            Some(true_colors) if true_color => true_colors,
            _ => colors.basic_colors,
        }
    }

    pub fn get_type(&self) -> LanguageType {
        match self {
            {% for language, attrs in languages -%}
                Language::{{ language }} => LanguageType::{{ attrs.type | title }},
            {% endfor %}
        }
    }

    pub fn get_circle_color(&self) -> DynColors {
        match self {
            {% for language, attrs in languages -%}
                {% set rgb = attrs.colors.chip | hex_to_rgb -%}
                Language::{{ language }} => Rgb({{ rgb.r }}, {{ rgb.g }}, {{ rgb.b }}),
            {% endfor %}
        }
    }
}

fn __loc<Any1, Any2>(language_type: Any1, language: Any2) -> usize {
    todo!("Determine if this is necessary")
    // match language_type {
    //     {% for language, attrs in languages -%}
    //         {%- set line_types = attrs.line_types | default(value=['code']) -%}
    //         tokei::LanguageType::{{ language }} => language.{{ line_types.0 }}{% for line_type in line_types | slice(start=1) %} + language.{{ line_type }}{% endfor %},
    //     {% endfor %}
    //     _ => unimplemented!("Language Type {:?}", language_type),
    // }
}


fn __stats_loc<Any1, Any2>(language_type: Any1, stats: Any2) -> usize {
    todo!("Determine if this is necessary")
    // match language_type {
	// {% for language, attrs in languages -%}
    //     {%- set line_types = attrs.line_types | default(value=['code']) -%}
	//     {%- if attrs.line_types -%}
    //         tokei::LanguageType::{{ language }} => stats.{{ line_types.0 }}{% for line_type in line_types | slice(start=1) %} + stats.{{ line_type }}{% endfor %},
	//     {% endif -%}
    // {% endfor %}
	// _ => stats.code
    // }
}

{% for language, attrs in languages -%}
    {% if attrs.colors.rgb %}
        {% set ansi_length = attrs.colors.ansi | length -%}
        {% set rgb_length = attrs.colors.rgb | length %}
        {% if ansi_length != rgb_length %}
            compile_error!("{{ language }}: ansi and rgb colors must be the same length");
        {% endif %}
    {% endif -%}
{% endfor -%}

{% set max_width = 40 -%}
{# NOTE Permitting trailing newline #}
{% set max_height = 26 -%}


{% for language, attrs in languages -%}
    {% set lines = attrs.ascii | split(pat="\n") -%}
    {% set height = lines | length -%}
    {% if height > max_height %}
        compile_error!("{{ language }}: ascii art must have {{ max_height - 1 }} or less lines, has {{ height }}");
    {% endif -%}

    {% for line in lines -%}
        {% set cleaned_line = line | strip_color_tokens -%}
        {% set width = cleaned_line | length -%}
        {% if width > max_width %}
            compile_error!("{{ language }}: ascii art line {{ loop.index }} must be {{ max_width }} or less characters wide");
        {% endif -%}
    {% endfor -%}
{% endfor -%}
